# -*- coding: utf-8 -*-
"""ToyStar2D.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yr5J5fSMthS8YPWdK_XL_jHIl4EzDcNO

#Imports Iniciais
"""

#Importar biblioteca numpy
import numpy as np
import math
import matplotlib.pyplot as plt
from tqdm import tqdm

"""#Constantes Iniciais"""

M=2 #Massa estrela
k=0.1 #constante de pressão
dt=0.04 #espaço de tempo
nu=1 #damping
n=1
N=100 #numero de partículas
m=M/N #Massa de cada partícula
h = 1 #Fator do kernel smoothing length
R=0.75 #Raio estrela
l=(8*M*k)/((R**4)*(math.pi)) #constante gravitacional
constante=(5)/((14)*((h)**2)*(math.pi)) #constante kernel 2D

"""#Criação das posições iniciais e de uma função para o cálculo de $||r_i - r_j||$"""

def modulo_diferenca(vec1,vec2):
  dif_x=(vec1[0]-vec2[0]) #coord x
  dif_y=(vec1[1]-vec2[1]) #coord y
  norma=np.sqrt(dif_x**2+dif_y**2) #Norma de x e y
  return norma,dif_x,dif_y

"""#A função kernel: $W(\textbf{$r_i - r_j$}, h)$"""

def kernel(r,h):
  #r=norma do r
#relação da distância com o valor do kernel aproximado por spline cubica
  rlinha=np.abs(r)
  q=rlinha/h
  if (0<=q) and (q<1): #caso q entre valores o kernel assume a função
    w=(constante)*(((2-q)**(3))-(4)*(1-q)**(3))
  elif (1<=q) and (q<2):
    w=(constante)*((2-q)**3)
  else:
    w=0   
  return w

"""#A função gradiente do kernel: $\nabla W(r_i - r_j, h)$"""

def Grad_kernelX(r,r1,h):
  #r=norma do r
  #r1=diferença entre ri e rj (delta(r))
#relação da distância com o valor do kernel aproximado por spline cubica
  rlinha=np.abs(r)
  q=rlinha/h
  sinal=1
  if (r1<0):
    sinal=-1
  if (0<=q) and (q<1):
    Grad_wx=(constante)*(r1/h**2)*(((12*(1-q)**2)-3*(2-q)**2)/(q))
  elif (1<=q) and (q<2):
    Grad_wx=(constante)*(-3/h)*((2-(rlinha)/h)**2)*sinal
  else:
    Grad_wx=0   
  return Grad_wx

def Grad_kernelY(r,r1,h):
  #rlinha=norma do r
  #r1=r
#relação da distância com o valor do kernel aproximado por spline cubica
  rlinha=np.abs(r)
  q=rlinha/h
  if (0<=q) and (q<1):
    Grad_wy=(constante)*((-3)*r1*(4-3*q))/(h**2)
  elif (1<=q) and (q<2):
    Grad_wy=(constante)*(-3)*r1*((rlinha-2*h)**2)/((h**3)*(rlinha))
  else:
    Grad_wy=0   
  return Grad_wy

#APAGUE ESSA CÉLULA!
#array_j=[]
##n=0
#array_outro=[]
#array_x=[]
#array_x1=[]
#array_y=[]
#array_y1=[]
#for i in range(N):
#  for j in range(N):
#    n,vetorx,vetory=modulo_diferenca(pos[i],pos[j])
#    if(n!=0):
#      array_outro.append(n)
#      array_x.append(vetorx)
#      array_y.append(vetory)
#      array_j.append(kernel(n,1))
#      array_x1.append(Grad_kernelY(n,vetory,1))
#      array_y1.append(Grad_kernelX(n,vetorx,1))
#vecc=np.linspace(-3,3,90)
#aaaa=[]
#teste21=[]
#cccc=[]
#for i in range(90):
#  aaaa.append(Grad_kernelX(vecc[i],vecc[i],1))
#plt.plot(vecc,aaaa)
#
#plt.grid()
#
#plt.show()

#testek=np.linspace(-3,3,90)
#for i in range(90):
#  teste21.append(kernel(testek[i],1))
#plt.plot(testek,teste21)
#
#plt.grid()
#
#plt.show()

"""# Função Densidade"""

def Densidade(pos,m,h):
  rhow=[] #inicia rho
  for i in range(N):
    rhow.append(0) #Preenche rho com zeors

  for i in range(N): 
    for j in range(N): 
      dif,difx,dify=modulo_diferenca(pos[i],pos[j])
      if (dif < 3*h):
        rhow[i]+=m*kernel(dif,h)
      
  return rhow

def atualiza_a(pos,l,nu,m,Pressao,rho,v,n,h):
  ac=np.zeros((N,2))
  for i in range(N):
    ac[i][0]+=-(nu*v[i][0])-(l*pos[i][0]) #adicionando o fator gravitacional e viscosidade
    ac[i][1]+=-(nu*v[i][1])-(l*pos[i][1])

  for i in range(N):
    for j in range(N):
      n,vetorx,vetory=modulo_diferenca(pos[i],pos[j])
      if (n!=0):
        if (n < 3*h):
          ac[i][0]+=(-m)*((Pressao[i]/(rho[i])**2)+(Pressao[j]/(rho[j])**2))*Grad_kernelX(n,vetorx,h) #adicionando o fator pressao
          ac[i][1]+=(-m)*((Pressao[i]/(rho[i])**2)+(Pressao[j]/(rho[j])**2))*Grad_kernelX(n,vetory,h)
          #ac[i][0]+=(-2*m*k)*Grad_kernelX(n,vetorx,h) #adicionando o fator pressao
          #ac[i][1]+=(-2*m*k)*Grad_kernelX(n,vetory,h)

  return ac

Pressao=[]
v_mhalf=np.zeros((N,2)) #inicia vminus=0
v_phalf=np.zeros((N,2)) #inicia vplus=0
v=np.zeros((N,2)) #todas as velocidades iniciais iguais a 0
pos=np.zeros((N,2)) # inicia o vetor posição
v_phalf=np.zeros((N,2)) #v_phalf iniciado 
a=np.zeros((N,2)) #inicia aceleração

for i in range(N):
  pos[i][0]=(np.random.random()-0.5)*2*R #coordenada x
  pos[i][1]=(np.random.random()-0.5)*2*R #coordenada y
  #Linha de pos = particula
  #Coluna de pos = coordenadas x e y da i-esima particula

for i in range(N):
  Pressao.append(0) #Vetor pressão [0,0,..,0]
rho=Densidade(pos,m,h) #atualiza a densidade inicial
for i in range(N):
  Pressao[i]=(k)*((rho[i])**2) #atualiza pressão
a=atualiza_a(pos,l,nu,m,Pressao,rho,v,n,h) #inicia o vetor aceleração

for i in range(N): #Inicia o v_mhalf com valores 
  v_mhalf[i][0]=v[i][0]-(0.5*dt*a[i][0])
  v_mhalf[i][1]=v[i][1]-(0.5*dt*a[i][1])

for t in tqdm(range(800)): #Tempo
  for i in range(N): #vetor de partículas no sistema
    v_phalf[i][0]= v_mhalf[i][0]+a[i][0]*dt #Calcula vplus x
    v_phalf[i][1]= v_mhalf[i][1]+a[i][1]*dt #calcula vplusy
    pos[i][0]+= v_phalf[i][0]*dt #atualiza posição x
    pos[i][1]+= v_phalf[i][1]*dt #atualiza posição y
    v[i][0]+= 0.5*(v_mhalf[i][0]+v_phalf[i][0]) #velocidade é a média entre v plus e v minus x
    v[i][1]+= 0.5*(v_mhalf[i][1]+v_phalf[i][1]) #mesma coisa y
    v_mhalf[i][0]=v_phalf[i][0] #atualiza v_mhal para a próxima interação x
    v_mhalf[i][1]=v_phalf[i][1] #atualiza v_mhalf y para a próxima interação y
  rho=Densidade(pos,m,h) #atualiza a densidade rho a cada instante de tempo passado
  for i in range(N):# atualiza pressão e aceleração para o próximo instante de tempo 
    Pressao[i]=(k)*((rho[i])**2)
  a=atualiza_a(pos,l,nu,m,Pressao,rho,v,n,h)



"""####Observação:
##### dt=0.04{
##### acima de h= 1.12, posx,y= 10^8 e primeira partícula anormal
##### h=0.7 posx=0.001 e primeira aprtícula anormal
#####h=0.5, posx,y= 0.005
##### h muito próximo de 0= posx,y= 10^(-8)  primeira partícula anormal}
"""

print(pos)

import math
import random
import matplotlib.pyplot as plt
colors = [random.randint(1, 8) for i in range(N)] #preciso arrumar isso. Cores quentes serão para rho maiores
areas = [math.pi * (1)**2 for i in range(N)] #Area do circulo (pi)*r^2
# plota a figura
plt.figure()
plt.scatter(pos[:,0],pos[:,1], s=areas, c=colors)

plt.xlabel("X")
plt.ylabel("Y")
plt.show()

rho

"""$$P=k \rho ^{1+1/n}\\
\rightarrow P_i=k\rho_i^{1+1/n}$$
#Analiticamente temos:
"""

Densi_anali=[]
Pressão_anali=[]
raiz=np.linspace(0,1,90)

for i in range(len(raiz)):
  calcu=(l/(4*k))*((R**2)-(raiz[i]**2))
  pressaoana=k*calcu**2
  Densi_anali.append(calcu)
  Pressão_anali.append(pressaoana)

plt.plot(raiz,Densi_anali)
plt.grid()
plt.title('Densidade analiticamente')
plt.xlabel('r')
plt.ylabel('Densidade')
plt.ylim(0, 3)
plt.xlim(0, 0.8)
plt.show()

plt.plot(raiz,Pressão_anali)
plt.grid()
plt.title('Pressão analiticamente')
plt.xlabel('r')
plt.ylabel('Pressão')
plt.xlim(0, 0.75)
plt.show()